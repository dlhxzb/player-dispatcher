# 架构
服务分两层：
* dispatcher：分发服务器
  * 管理所有地图服务器，后台线程监视各服务器负载，发起扩缩容请求
  * 缓存用户-服务器映射，以此为依据将请求分发到地图服务器
* map-server：地图服务器
  * world-server：世界地图服务器。处理除区域服务器之外的玩家。1~n台
  * zone-server：区域服务器。处理区域内的玩家。0~n台

一开始也考虑了zone的定义完全动态，广度优先的搜索周围可融合的区域，
但是考虑在扩缩容之后zone可能会碎片化，不好管理，现在简单的定义为世界地图的静态均匀划分。  
实际场景中可以按需要自己定义zone（如拍卖行等人口

# 并发一致性
考虑到写请求不少，不太符合RwLock的应用场景。
为实现无锁，使用跳表（Skiplist）来记录服务器清单、玩家清单。  
缺点是skiplist会排序，但这并不是我的需求，会有性能损耗。  
另外跳表也无法保证先读后写是原子的，除非上锁，否则存在数据竞争。例如两人同时给玩家money+1，可能最后只+1。  
  
解决方案：考虑以玩家为单位将请求串行起来（ert crate）

# API流程
### login
* dispatcher根据坐标计算分到哪个地图服务器
* 地图服务器login
* dispatcher加入用户缓存

### aoe
* dispatcher根据范围坐标计算分到一台或几台地图服务器
* 各地图服务器处理aoe

### move
* dispatcher从缓存中取出用户当前zone
* dispatcher计算移动目标zone，
  * 如果不是当前zone：
    * 调用当前地图服务器export_play_to到目标服务器
    * dispatcher更新用户-服务器缓存
    * 将move请求发送给目标服务器
  * 如果是当前zone，则将move发给原地图服务器

# 动态扩缩容流程
设服务器最大人数MAX（扩容），最低人数MIN（缩容），  
针对从世界服某一区域扩展出区域服务器时，为避免频繁扩缩，应保证划分到新增区域服务器人数>=MAX/2

### 扩容
dispatcher监视到某一服务器玩家大于MAX，根据此服务器类型
* 区域服务器（z1）
  * dispatcher启动一台相同区域服务器（z2）
  * dispatcher调用z1 export_play_to API，将一半用户导入z2
  * dispatcher更新用户-服务器缓存
* 世界服务器
  * 有多个世界服务器之后对各个zone人数不好统计了


# 新想法
三叉树区域扩展，四个区域1234，统一由dispatcher管理。父节点最多拆分出三个区域剩下一个自己管理  
定位玩家坐标到zone：123代表世界地图划分四份后的左上，再划分后右上，再划分后左下。
如果算出来玩家在区域123，先查123区域服务器是否创建，再查12，然后1，最后0  
缺点：缩容的时候从叶子节点开始缩，会有非叶子节点服务器浪费（如果把父节点缩容至祖父节点，那么再扩容时，玩家的区域就混乱了）

假设100扩容，25缩容
* Z5(100) -> Z5(60)，Z51（40）
* 然后Z5增加40 -> Z5(20)，Z51（40），Z53(80)
* 然后Z51增加60 -> Z5(20)，Z51（10），Z53(80)，Z513(90)
此时叶子节点只有Z513和Z53，而父节点Z5和Z53已减少至缩容人数，却无法缩容  
如果 Z5(30)，Z53(80)，Z513(90)，似乎也没什么问题

当区域不可再划分时，同一区域可有多台服务器。


